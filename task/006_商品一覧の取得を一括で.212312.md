# 商品一覧の取得を一括で行う設計書

**作成日**: 2026年2月5日
**LLMモデル**: Claude Opus 4.5 (claude-opus-4-5-20251101)

---

## 1. 背景と目的

### 1.1 現状の課題

Netlifyの無料枠では、Functions（サーバーレス関数）の呼び出し回数が**月300回**に制限されている。現在の実装では、部門タブを切り替えるたびにAPIが呼び出されるため、アクセス数が増加しやすい状況にある。

### 1.2 現在のアクセスパターン（1セッションあたり）

| 操作 | API呼び出し回数 |
|------|----------------|
| ログイン | 1回（auth） |
| 商品一覧画面初回読み込み | 3回（categories + product-images + products） |
| 部門タブ切り替え（1回あたり） | 1回（products） |
| 商品更新 | 2回（PATCH + GET） |

**例**: 5部門を持つ店舗で、全部門をそれぞれ1回ずつ確認すると：
- 初回: 3回
- タブ切り替え: 5回
- **合計: 8回/セッション**

### 1.3 目標

- 部門タブ切り替え時のAPI呼び出しを**0回**にする
- 初回読み込み時に全商品を一括取得し、部門別表示はクライアント側でフィルタリング
- 検索機能と同様のアプローチを採用

---

## 2. 設計方針

### 2.1 基本方針

**「全商品を一括取得し、クライアント側でフィルタリング」**

1. 画面読み込み時に全商品データを一括で取得
2. 取得したデータをメモリ上に保持
3. 部門タブ切り替え時は、保持しているデータからJavaScriptでフィルタリング
4. API呼び出しは初回のみ

### 2.2 採用理由

- **商品数が多くない**という前提条件に適合
- 既存の検索機能がクライアント側フィルタリングで実装済み（同じパターンを適用）
- 実装の変更範囲が限定的

### 2.3 制約条件の確認

| 項目 | 状況 |
|------|------|
| 商品数 | 多くない（数百件程度を想定） |
| ブラウザメモリ | 問題なし（商品データは軽量） |
| 初回読み込み時間 | 許容範囲（全商品でも数秒以内） |

---

## 3. アクセス数の比較

### 3.1 現在の実装

```
初回読み込み: 3回
部門タブ切り替え（N回）: N回
商品更新: 2回
---------------------------------
合計: 5 + N 回/セッション
```

### 3.2 改善後の実装

```
初回読み込み: 3回（変更なし）
部門タブ切り替え（N回）: 0回 ← 削減
商品更新: 1回 ← 再読み込み不要に変更可能
---------------------------------
合計: 3〜4回/セッション
```

### 3.3 削減効果

| ユースケース | 現在 | 改善後 | 削減率 |
|-------------|------|--------|-------|
| 5部門を確認 | 8回 | 3回 | 62.5% |
| 10部門を確認 | 13回 | 3回 | 76.9% |
| 商品更新込み | 15回 | 4回 | 73.3% |

---

## 4. 詳細設計

### 4.1 データ構造の変更

#### 現在のProductsPageクラスの状態

```
ProductsPage
├── products: []           // 現在表示中の商品（部門別に取得）
├── categories: []         // 部門一覧
├── selectedCategoryId     // 選択中の部門ID
├── changedProducts: Set   // 変更された商品ID
├── originalProducts: Map  // オリジナル商品データ
└── productImages: Map     // 商品画像マップ
```

#### 改善後の状態

```
ProductsPage
├── allProducts: []        // 全商品データ（一括取得、新規追加）
├── displayProducts: []    // 表示用商品（フィルタリング結果）
├── categories: []         // 部門一覧
├── selectedCategoryId     // 選択中の部門ID
├── changedProducts: Set   // 変更された商品ID
├── originalProducts: Map  // オリジナル商品データ
└── productImages: Map     // 商品画像マップ
```

### 4.2 処理フローの変更

#### 現在の処理フロー

```
init()
  └── loadData()
       ├── getCategories() → API呼び出し
       ├── getProductImages() → API呼び出し
       ├── renderCategoryTabs()
       └── loadProducts() → API呼び出し（部門指定）

タブクリック時:
  └── loadProducts() → API呼び出し（部門指定）
```

#### 改善後の処理フロー

```
init()
  └── loadData()
       ├── getCategories() → API呼び出し
       ├── getProductImages() → API呼び出し
       ├── getAllProducts() → API呼び出し（全商品、1回のみ）
       ├── renderCategoryTabs()
       └── filterAndDisplayProducts() → ローカル処理

タブクリック時:
  └── filterAndDisplayProducts() → ローカル処理のみ（API呼び出しなし）
```

### 4.3 主要メソッドの変更点

#### 4.3.1 loadData() メソッド

**変更内容**:
- `loadProducts()` の呼び出しを `loadAllProducts()` + `filterAndDisplayProducts()` に変更

**処理フロー**:
1. categories、productImages、allProducts を並列取得
2. 全データ取得後、初期表示（全商品 or デフォルト部門）

#### 4.3.2 新規: loadAllProducts() メソッド

**責務**:
- 全商品を一括で取得してallProductsに保存
- category_idパラメータは指定しない

**呼び出し**:
```
this.api.getProducts({ sort: 'displaySequence' })
```

#### 4.3.3 新規: filterAndDisplayProducts() メソッド

**責務**:
- allProductsから選択中の部門に該当する商品を抽出
- 抽出結果をdisplayProductsに設定
- renderProducts()を呼び出して表示

**フィルタリングロジック**:
```
selectedCategoryId が null の場合:
  → allProducts をそのまま使用（全商品表示）

selectedCategoryId が指定されている場合:
  → allProducts から categoryId が一致するものを抽出
```

#### 4.3.4 タブクリック時の処理

**現在**:
```
タブクリック → selectedCategoryId更新 → loadProducts()（API呼び出し）
```

**改善後**:
```
タブクリック → selectedCategoryId更新 → filterAndDisplayProducts()（ローカル処理）
```

### 4.4 商品更新後の処理

#### 現在の実装

```
updateProducts() → PATCH API → loadProducts() → GET API（再取得）
```

#### 改善案A: ローカルで状態を更新（推奨）

```
updateProducts() → PATCH API → ローカルでallProductsを更新 → filterAndDisplayProducts()
```

- API呼び出し: 1回（PATCHのみ）
- サーバーからの再取得は不要（変更内容はクライアントが把握済み）

#### 改善案B: 再取得を維持

```
updateProducts() → PATCH API → loadAllProducts() → GET API → filterAndDisplayProducts()
```

- API呼び出し: 2回（PATCH + GET）
- データの整合性を重視する場合

**推奨**: 改善案Aを採用。PATCH成功時のレスポンスに更新後データが含まれる場合は、それを使用してローカル更新。

---

## 5. 影響範囲

### 5.1 変更が必要なファイル

| ファイル | 変更内容 |
|---------|---------|
| `public/js/products-page.js` | メインロジックの変更 |

### 5.2 変更不要なファイル

| ファイル | 理由 |
|---------|------|
| `public/js/api.js` | API呼び出しメソッドは変更不要 |
| `netlify/functions/products.js` | サーバー側は変更不要 |
| `public/pages/products.html` | HTML構造は変更不要 |

### 5.3 テスト観点

1. **初回読み込み**: 全商品が正しく取得されるか
2. **部門タブ切り替え**: フィルタリングが正しく動作するか
3. **検索機能**: 部門フィルタと検索フィルタの組み合わせ
4. **商品更新**: 更新後の表示が正しいか
5. **変更追跡**: changedProductsの追跡が正しく動作するか
6. **パフォーマンス**: 商品数が多い場合のレスポンス

---

## 6. 追加の改善提案

### 6.1 キャッシュの導入（オプション）

**目的**: ページリロード時のAPI呼び出しを削減

**方法**:
- 商品データをLocalStorageまたはSessionStorageにキャッシュ
- キャッシュの有効期限を設定（例: 5分）
- 有効期限内であればキャッシュを使用

**効果**:
- ページリロード時のAPI呼び出しを0回に削減可能
- ただし、データの鮮度とのトレードオフあり

**判断**: ユーザーの利用パターン次第。頻繁にリロードする場合は有効。

### 6.2 部門データのキャッシュ（オプション）

**目的**: 部門一覧の取得も削減

**方法**:
- 部門データは商品データより変更頻度が低い
- より長い有効期限でキャッシュ可能（例: 1時間）

### 6.3 画像データのキャッシュ（オプション）

**現状**: product-imagesは毎回取得している

**改善案**:
- 画像URLは変更頻度が低い
- LocalStorageにキャッシュして再利用

---

## 7. 実装優先度

| 優先度 | 内容 | 効果 |
|--------|------|------|
| **高** | 部門タブ切り替えのローカルフィルタリング化 | 最大の削減効果 |
| **中** | 商品更新後のローカル状態更新 | 更新操作のAPI呼び出し半減 |
| **低** | データのキャッシュ導入 | リロード時の削減（利用パターン次第） |

---

## 8. まとめ

### 8.1 主な変更点

1. **全商品の一括取得**: 初回読み込み時に全商品を取得してメモリに保持
2. **クライアント側フィルタリング**: 部門タブ切り替え時はAPI呼び出しなしでフィルタリング
3. **商品更新後のローカル更新**: 可能であれば再取得を省略

### 8.2 期待される効果

- **API呼び出し回数**: 5〜15回/セッション → 3〜4回/セッション（60〜80%削減）
- **月間300回の枠内で**: より多くのセッションに対応可能
- **ユーザー体験**: タブ切り替えが即座に反映（通信待ち時間なし）

### 8.3 トレードオフ

| メリット | デメリット |
|---------|-----------|
| API呼び出し大幅削減 | 初回読み込みのデータ量増加 |
| タブ切り替えが高速化 | メモリ使用量の増加（軽微） |
| シンプルな実装変更 | データの鮮度が低下する可能性（長時間操作時） |

### 8.4 リスクと対策

| リスク | 対策 |
|--------|------|
| 商品数が増加した場合のパフォーマンス | 将来的にページネーションを検討 |
| データの不整合（他ユーザーによる更新） | 必要に応じて手動リフレッシュボタンを追加 |

---

## 9. 決定事項

### 9.1 商品更新後の処理

**採用**: 改善案A（ローカルで状態を更新）

```
updateProducts() → PATCH API → ローカルでallProductsを更新 → filterAndDisplayProducts()
```

- API呼び出し: 1回（PATCHのみ）
- PATCH成功後、クライアント側でallProductsの該当商品を更新
- サーバーからの再取得は行わない

---

## 10. 残りの確認事項（オプション）

以下は実装を進める上で、必要に応じて確認させてください：

1. **商品数の上限**: 現在の商品数と、今後想定される最大商品数はどの程度ですか？（数百件程度であれば問題なし、数千件以上の場合は別途対策が必要）

2. **データの鮮度**: 複数ユーザーが同時に商品情報を編集する可能性はありますか？（ある場合、データの整合性維持方法を検討）

3. **キャッシュの導入**: オプションのキャッシュ機能（6.1〜6.3）の導入は希望されますか？

---

以上が設計書となります。ご確認をお願いいたします。
